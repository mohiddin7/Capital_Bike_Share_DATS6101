---
title: "CaBi"
author: "TEAM SIM"
date: "2023-04-27"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
```
```{r}

library(ezids)
library(dplyr)
library(ggmap)
library(ggplot2)
library(tidyverse)
library(corrplot)
library(knitr)
library(kableExtra)
library(tidyr)
library(lubridate)
library(shiny)
library(igraph)
```


```{r}
# Read in "CaBi.csv" file as a data frame called "CaBi"
CaBi <- read.csv("CaBi.csv")
```
```{r}
# Displaying the first few rows of the "CaBi" data frame to check its contents and ensure that it was read in correctly.
head(CaBi)
```

```{r}
# citation("ggmap")
# register_google(key = "put api key here")
# 
# geocodes <- geocode(CaBi$start_station_name)
# 
# # merge the geocodes back into the original data
# CaBi <- cbind(CaBi,geocodes)
# 
# # create a map using ggmap
# CaBi_map <- get_map(location = "Washington D.C.", zoom = 12)
# 
# # create a dot map on the map
# ggmap(CaBi_map) +
#   geom_point(data = CaBi, aes(x = lon, y = lat, fill = my_var), alpha = 0.6, size = 5)

```

```{r}
# Checking for missing values and duplicates.
sum(is.na(CaBi))
sum(is.na(CaBi$holiday))



sum(duplicated(CaBi))


```
```{r}
sapply(CaBi, class)

summary(CaBi)
```


```{r}
CaBiO <- CaBi
CaBi$started_at <- strptime(CaBi$started_at,format="%Y-%m-%d",tz = "EST")
```
```{r}
# street_address <- unique(sort(CaBi$start_station_name))
# write.csv(street_address,"street_address.csv")



print(sum(CaBi$start_station_name==""))



subset(CaBi, start_station_name == "")[, c("noofbikes", "started_at","date","month","year")]

CaBi$start_station_name[CaBi$start_station_name == ""] <- NA

```
# The below code is for data cleaning and transformation of the `member_type` column in the "CaBi" data frame. It first displays unique values in the `member_type` column. Then it standardizes the capitalization of `casual` and `member` categories by replacing inconsistent values with lowercase. It counts the number of rows with the "Unknown" value in the `member_type` column and removes those rows from the data frame since they can't be classified. Finally, it converts the `member_type` column to a factor for efficient storage and analysis.

```{r}
unique(CaBi$member_type)


CaBi$member_type[CaBi$member_type == "Casual"] <- "casual"
CaBi$member_type[CaBi$member_type == "Member"] <- "member"

sum(CaBi$member_type == "Unknown")

CaBi <- CaBi[CaBi$member_type != "Unknown", ]

CaBi$member_type <- as.factor(CaBi$member_type)

```
# Converting `duration` column to a numeric format and rounding it to two decimal places, and removing rows with negative values.
```{r}
class(CaBi$duration)

CaBi$duration <- round(as.double(CaBi$duration), 2)

CaBi <- CaBi[CaBi$duration > 0, ]
```

# Standardizing `weather` categories in the `CaBi` data frame by grouping similar weather conditions together and converting it to a factor for efficient storage and analysis.
```{r}
unique(CaBiO$weather)


CaBi$weather[CaBi$weather == "Partially cloudy"] <- "Cloudy"
CaBi$weather[CaBi$weather == "Rain, Overcast"] <- "OvercastRain"
CaBi$weather[CaBi$weather == "Rain, Partially cloudy"] <- "Rain"
CaBi$weather[CaBi$weather == "Snow, Rain, Overcast"] <- "Overcast"
CaBi$weather[CaBi$weather == "Snow, Rain, Partially cloudy"] <- "Cloudy"
CaBi$weather[CaBi$weather == "Snow, Partially cloudy"] <- "Snow"
CaBi$weather[CaBi$weather == "Snow, Overcast"] <- "OvercastSnow"
CaBi$weather[CaBi$weather == "Snow, Rain"] <- "Rain"



CaBi$weather <- as.factor(CaBi$weather)
```


```{r}
# Converting "weekday" column to a factor for efficient storage and analysis.
unique(CaBi$weekday)


CaBi$weekday <- as.factor(CaBi$weekday)
```
# Creating a new factor variable `holiday` in the "CaBi" data frame that indicates whether a date is a holiday or not based on the `holiday` column where holiday names are removed and replaced with `holiday` value.
```{r}
# unique(CaBi$holiday)

CaBi$holiday[!is.na(CaBi$holiday)] <- "holiday"
CaBi$holiday[is.na(CaBi$holiday)] <- "not holiday"


CaBi$holiday <- as.factor(CaBi$holiday)
```

```{r}
# Converting `season` column to a factor for efficient storage and analysis.
unique(CaBi$season)


CaBi$season <- as.factor(CaBi$season)
```
# Removing the `date` column from the "CaBi" data frame as it is no longer needed for the analysis.
```{r}
CaBi$date <- NULL


```

# Converting `month` column to a factor and changing factor levels to month names for easier interpretation.
```{r}
CaBi$month <- as.factor(CaBi$month)
levels(CaBi$month) <- month.name[1:12]
```

# Converting `year` column to numeric for efficient storage and analysis.
```{r}
CaBi$year <- as.numeric(CaBi$year)

```
# Printing a summary of the "CaBi" data frame, showing the class of each column, and removing the "CaBiO" object from the environment, so that storage space is used for other objects
```{r}
summary(CaBi)
sapply(CaBi, class)
rm(CaBiO)
rm(street_address)
```


```{r}
# Exporting the cleaned "CaBi" data frame to a CSV file.
write.csv(CaBi,file = "CaBi_cleaned.csv",row.names = F)

```

## EDA


```{r}
# Aggregate data by season
season_data <- aggregate(CaBi$noofbikes, by = list(CaBi$season), FUN = sum)

# Calculate percentages
season_data$percentage <- season_data$x/sum(season_data$x) * 100

# Create bar chart with percentages and different colors
ggplot(season_data, aes(x=Group.1, y=percentage, fill=Group.1)) + 
  geom_bar(stat="identity") + 
  geom_text(aes(label=paste0(x)), 
            position=position_stack(vjust=0.5), size=3) +
  labs(title="Bike Rental Demand by Season", x="Season", y="Percentage") +
  scale_fill_manual(values=c("#FFCC66", "#99CC99", "#FF9999", "#89F1FF")) +
  theme_minimal()
```

```{r}
# subset the data to include only the relevant variables
data <- subset(CaBi, select = c(noofbikes, season))

# fit ANOVA model
model <- aov(noofbikes ~ season, data = data)

# summary of ANOVA model
summary(model)
```

# The below scatter plot shows that bike rental demand is influenced by both temperature and season. It indicates that the demand is highest in the spring and summer, with a peak in May and June, and less in the winter.
```{r}
ggplot(CaBi, aes(x = temperature, y = noofbikes, color = season)) +
  geom_point(alpha = 0.5, size = 2.5) +
  facet_wrap(~season, nrow = 2) +
  labs(title = "Bike Rental Demand by Season and Temperature",
       x = "Temperature", y = "Number of Bikes", color = "Season") +
  scale_color_manual(values = c("#FFCC66", "#99CC99", "#FF9999", "#89F1FF"))
```

# The below plot shows that bike rental demand is higher on cloudy and clear days, followed by rainy days, and lower on days with overcast snow.
```{r}
ggplot(CaBi, aes(x = weather, y = noofbikes)) + 
  geom_boxplot(fill = "lightblue", alpha = 0.7) +
  labs(title = "Bike Demand by Weather Conditions", x = "Weather", y = "Number of Bikes") +
  theme_bw()

```

# The below scatter plot displays the distribution of bike rentals by weather condition, with each point representing the number of bikes rented during a specific weather condition. The plot indicates that the highest demand for bike rentals occurs on cloudy and clear days, followed by rainy and overcast days.
```{r}
ggplot() + 
  geom_jitter(aes(weather,noofbikes,color = weather),alpha=0.5, data=CaBi, show.legend = FALSE) + 
  labs(title = "Distribution of Bikes by Weather Condition") + ylab("Number of Bikes") + xlab("Weather Condition")

```



# Creating a correlation matrix and plot of the variables in the CaBi dataset.
```{r}

# Select variables of interest
variables <- c("noofbikes","temperature","feelsliketemp","dew","humidity","windspeed","uvindex")

# Create correlation matrix
corr_matrix <- cor(CaBi[, variables], use = "pairwise.complete.obs")

tbl <- kable(round(corr_matrix,2))
tbl


# Plot correlation matrix
corrplot(corr_matrix, type = "upper", order = "hclust", tl.col = "#FF9999", tl.srt = 45, tl.cex = 0.8)


```
# Creating a Shiny app with a checkbox input for selecting the year and a plot output that displays the number of bikes rented in different duration bins. The app uses the ggplot2 package to create a stacked bar chart, where the fill color represents the number of bikes rented. The chart is updated dynamically based on the selected year.
```{r}

# Load the data
data <- CaBiO

# Create the user interface
ui <- fluidPage(
  
  # Add input checkbox for year
  checkboxGroupInput("year", label = "Select year", 
                     choices = unique(data$year), 
                     selected = unique(data$year)),
  
  # Add output plot for number of bikes and duration
  plotOutput("bike_duration_plot")
)

# Create the server
server <- function(input, output) {
  
  # Create duration bins
  data$duration_bins <- cut(data$duration, 
                            breaks = c(0,900,1800,3200,7592116),
                            labels = c("Short", "Medium", "Long", "Very Long"))
  
  # Filter data by year
  filtered_data <- reactive({
    data %>%
      filter(year %in% input$year)
  })
  
  # Plot number of bikes and duration
  output$bike_duration_plot <- renderPlot({
    ggplot(filtered_data(), aes(x = duration_bins)) +
      geom_bar(aes(fill = noofbikes), position = "dodge") +
      labs(x = "Duration Bins", y = "Number of Bikes") +
      scale_fill_gradient(low = "blue", high = "red") +
      theme_bw()
  })
}

# Run the app
shinyApp(ui = ui, server = server)

```
